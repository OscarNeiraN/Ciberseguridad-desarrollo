// Definición del Pipeline Declarativo
pipeline {
    // Agente de ejecución. Asume que se ejecuta en un nodo Jenkins estándar con Docker y Python.
    agent any

    // Variables de entorno globales.
    environment {
        // Asumiendo que esta variable ya está configurada como Secret Text en Jenkins
        SNYK_TOKEN = credentials('snyk-auth-token') 
        // URL de la aplicación para el escaneo ZAP
        APP_URL = 'http://127.0.0.1:5000'
        // Nombre de la imagen Docker
        DOCKER_IMAGE = 'oneiran/securedev:latest'
    }

    stages {
        // 1. Clonar el repositorio
        stage('Checkout') {
            steps {
                // Este paso se repite para asegurar que el workspace esté limpio y apuntando a 'main'.
                git branch: 'main', credentialsId: 'github-creds', url: 'https://github.com/OscarNeiraN/Ciberseguridad-desarrollo.git'
            }
        }

        // 2. Instalar dependencias y preparar el entorno de Python
        stage('Install Dependencies') {
            steps {
                sh 'echo Creando entorno virtual...'
                sh 'python3 -m venv venv'
                sh 'echo Instalando dependencias...'
                sh './venv/bin/pip install --upgrade pip'
                sh './venv/bin/pip install -r requirements.txt'
            }
        }

        // 3. Análisis Estático de Código (SAST) - Bandit
        stage('Bandit Security Scan') {
            steps {
                sh 'echo Ejecutando Bandit...'
                // Ejecuta Bandit, genera reportes JSON y HTML, y usa 'true' para no fallar el pipeline si encuentra vulnerabilidades.
                sh './venv/bin/bandit -r . -f json -o bandit-report.json'
                sh './venv/bin/bandit -r . -f html -o bandit-report.html'
            }
            post {
                always {
                    archiveArtifacts artifacts: 'bandit-report.*', fingerprint: true
                }
            }
        }

        // 4. Análisis Estático de Código (SAST) - Snyk Code
        stage('Snyk Code Scan (SAST)') {
            steps {
                // Autenticación con el token de Snyk
                withCredentials([string(credentialsId: 'snyk-auth-token', variable: 'SNYK_TOKEN')]) {
                    sh 'snyk auth $SNYK_TOKEN'
                    sh 'echo Ejecutando Snyk Code...'
                    // Genera reportes JSON y SARIF
                    sh 'snyk code test --json > snyk-code-report.json || true'
                    sh 'snyk code test --sarif > snyk-code-report.sarif || true'
                }
            }
            post {
                always {
                    archiveArtifacts artifacts: 'snyk-code-report.*', fingerprint: true
                }
            }
        }

        // 5. Análisis de Dependencias (SCA) - Snyk
        stage('Snyk Dependency Scan') {
            steps {
                sh 'echo Analizando dependencias...'
                // Genera reportes JSON y SARIF para dependencias
                sh 'snyk test --json > snyk-dep-report.json || true'
                sh 'snyk test --sarif > snyk-dep-report.sarif || true'
            }
            post {
                always {
                    archiveArtifacts artifacts: 'snyk-dep-report.*', fingerprint: true
                }
            }
        }

        // 6. Análisis de Seguridad del Contenedor - Snyk
        stage('Snyk Container Scan') {
            steps {
                sh """
                    # Construye la imagen Docker
                    docker build -t ${DOCKER_IMAGE} .
                    echo Ejecutando escaneo de contenedor...
                    # Escanea la imagen
                    snyk container test ${DOCKER_IMAGE} --json > snyk-container-report.json || true
                    snyk container test ${DOCKER_IMAGE} --sarif > snyk-container-report.sarif || true
                """
            }
            post {
                always {
                    archiveArtifacts artifacts: 'snyk-container-report.*', fingerprint: true
                }
            }
        }

        // 7. Análisis Dinámico de Aplicaciones (DAST) - OWASP ZAP
        stage('OWASP ZAP Active Scan') {
            steps {
                sh """
                    PYTHON_EXE=./venv/bin/python3
                    
                    echo 1. Creando y poblando la base de datos (database.db)...
                    # Ejecución del script de inicialización de DB
                    \${PYTHON_EXE} create_db.py

                    echo 2. Iniciando aplicación Flask temporal...
                    # Inicia la aplicación en background. Se usa 'vulnerable_app.py' para coincidir con el Dockerfile.
                    nohup \${PYTHON_EXE} vulnerable_app.py > flask.log 2>&1 &
                    echo \$! > flask.pid
                    
                    echo Dando 5 segundos a Flask para iniciar...
                    sleep 5
                    
                    echo 3. Esperando que Flask inicie (Máx 40s)...
                    READY=0
                    TIMEOUT=20
                    COUNT=0
                    while [ \$COUNT -lt \$TIMEOUT ]; do
                        if curl -s \${APP_URL}; then
                            READY=1
                            break
                        fi
                        COUNT=\$((COUNT + 1))
                        echo Esperando... (\$COUNT/\$TIMEOUT)
                        sleep 2
                    done

                    if [ \$READY -eq 1 ]; then
                        echo Servidor Flask iniciado. Iniciando escaneo ZAP...
                        
                        # **AQUÍ DEBE IR EL COMANDO ZAP REAL**
                        # Ejemplo: docker run -v \$(pwd):/zap/wrk/:rw -i owasp/zap2docker-stable zap-cli --zap-url http://127.0.0.1:8080 active-scan \${APP_URL} --output-file zap-report.html || true

                    else
                        echo =========================================
                        echo DIAGNÓSTICO: El servidor Flask no respondió. Revisando flask.log...
                        [ -f flask.log ] && cat flask.log
                        echo =========================================
                        echo ADVERTENCIA: Flask no respondió. Saltando ZAP.
                        true
                    fi
                """
            }
            post {
                always {
                    sh """
                        # Detener el proceso Flask usando el PID
                        if [ -f flask.pid ]; then
                            PID=\$(cat flask.pid)
                            echo Deteniendo proceso Flask con PID: \$PID
                            kill \$PID || true # '|| true' previene fallos si el proceso ya murió
                            rm -f flask.pid
                        fi
                        # Limpiar la DB
                        rm -f database.db
                    """
                    archiveArtifacts artifacts: 'flask.log, zap-report.*'
                }
            }
        }
        
        // 8. Empujar la imagen Docker al registro (Docker Hub)
        stage('Push Docker Image') {
            steps {
                // Asume que la credencial 'docker-creds' contiene usuario y contraseña.
                withCredentials([usernamePassword(credentialsId: 'docker-creds', passwordVariable: 'DOCKER_PASS', usernameVariable: 'DOCKER_USER')]) {
                    sh 'echo ${DOCKER_PASS}' // El log muestra que se enmascara la contraseña
                    sh 'docker login -u ${DOCKER_USER} --password-stdin'
                    sh 'docker push ${DOCKER_IMAGE}'
                }
            }
        }

        // 9. Despliegue a EC2
        stage('Deploy to EC2') {
            steps {
                // Asegura permisos para la clave SSH
                sh 'chmod 400 jenkins/claves-jenkins-ubuntu.pem' 
                
                // Comando SSH para el despliegue Blue/Green (Stop -> Remove -> Pull -> Run)
                sshagent(credentials: ['ec2-ssh-key-id']) { // Reemplaza 'ec2-ssh-key-id' con el ID de tu credencial SSH
                    sh """
                        ssh -o StrictHostKeyChecking=no -i jenkins/claves-jenkins-ubuntu.pem ec2-user@3.237.37.98 << EOF
                            docker stop app || true
                            docker rm app || true
                            docker pull ${DOCKER_IMAGE}
                            docker run -d --restart always --name app -p 80:5000 ${DOCKER_IMAGE}
                        EOF
                    """
                }
            }
        }
    }

    // Acciones de Post-Ejecución
    post {
        always {
            echo "Pipeline completado. Todos los reportes de seguridad fueron archivados."
        }
        success {
            echo "¡El pipeline finalizó exitosamente!"
        }
        failure {
            echo "El pipeline falló. Revisa los logs de la etapa problemática."
        }
    }
}