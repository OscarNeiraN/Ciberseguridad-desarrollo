pipeline {
    agent any

    // Variables de entorno globales.
    environment {
        // Credenciales y URLs definidas por el usuario
        DOCKER_IMAGE = "oneiran/securedev:latest"
        EC2_USER = "ec2-user"
        EC2_IP = "3.237.37.98"
        EC2_KEY = "jenkins/claves-jenkins-ubuntu.pem"
        // ID de la credencial de Snyk proporcionada por el usuario
        SNYK_TOKEN = credentials('snyk-token')
        // URL de la aplicación para el escaneo DAST
        APP_URL = 'http://127.0.0.1:5000'
    }

    stages {

        /* ==========================
         * CHECKOUT
         * ========================== */
        stage('Checkout') {
            steps {
                git branch: 'main',
                    credentialsId: 'github-creds',
                    url: 'https://github.com/OscarNeiraN/Ciberseguridad-desarrollo.git'
            }
        }

        /* ==========================
         * VIRTUAL ENV
         * ========================== */
        stage('Install Dependencies') {
            steps {
                sh """
                    echo "Creando entorno virtual..."
                    python3 -m venv venv

                    echo "Instalando dependencias..."
                    ./venv/bin/pip install --upgrade pip
                    ./venv/bin/pip install -r requirements.txt
                """
            }
        }

        /* ==========================
         * BANDIT (SAST)
         * ========================== */
        stage('Bandit Security Scan') {
            steps {
                sh """
                    echo "Ejecutando Bandit..."
                    ./venv/bin/bandit -r . -f json -o bandit-report.json || true
                    ./venv/bin/bandit -r . -f html -o bandit-report.html || true
                """
            }
            post {
                always {
                    archiveArtifacts artifacts: 'bandit-report.*', fingerprint: true
                }
            }
        }

        /* ==========================
         * SNYK CODE (SAST)
         * ========================== */
        stage('Snyk Code Scan (SAST)') {
            steps {
                sh """
                    snyk auth ${SNYK_TOKEN}
                    echo "Ejecutando Snyk Code..."
                    snyk code test --json > snyk-code.json || true
                    snyk code test --sarif > snyk-code.sarif || true
                """
            }
            post {
                always {
                    archiveArtifacts artifacts: 'snyk-code.*', fingerprint: true
                }
            }
        }

        /* ==========================
         * SNYK DEPENDENCIAS (SCA)
         * ========================== */
        stage('Snyk Dependency Scan') {
            steps {
                sh """
                    echo "Analizando dependencias..."
                    snyk test --json > snyk-deps.json || true
                    snyk test --sarif > snyk-deps.sarif || true
                """
            }
            post {
                always {
                    archiveArtifacts artifacts: 'snyk-deps.*', fingerprint: true
                }
            }
        }

        /* ==========================
         * SNYK CONTENEDOR (Container Scan)
         * ========================== */
        stage('Snyk Container Scan') {
            steps {
                sh """
                    # La imagen debe construirse antes de escanearla
                    docker build -t ${DOCKER_IMAGE} .
                    echo "Ejecutando escaneo de contenedor..."
                    snyk container test ${DOCKER_IMAGE} --json > snyk-container.json || true
                    snyk container test ${DOCKER_IMAGE} --sarif > snyk-container.sarif || true
                """
            }
            post {
                always {
                    archiveArtifacts artifacts: 'snyk-container.*', fingerprint: true
                }
            }
        }

        /* ==========================
         * OWASP ZAP ACTIVE SCAN + AUTH (DAST)
         * ========================== */
        stage('OWASP ZAP Active Scan') {
            // PRIMER PASO: CREAR ZAP.YAML USANDO writeFile (Soluciona el error de permisos)
            steps {
                echo "1. Creando zap.yaml usando writeFile..."
                writeFile file: 'zap.yaml', text: """
env:
  contexts:
  - name: auth-context
    urls:
      - ${APP_URL}
    authentication:
      method: formBasedAuthentication
      parameters:
        loginPageUrl: ${APP_URL}/login
        loginPostData: "username={%username%}&password={%password%}"
      verification:
        method: response
        # La página de dashboard contiene 'Welcome, user'
        loggedInRegex: 'Welcome, user' 
    users:
      - name: testuser
        credentials:
          username: testuser_zap
          password: TestPassword123
jobs:
# 1. Configuración de Escaneo Pasivo
- type: passiveScan-config
  parameters:
    enableTags: false
    maxAlertsPerRule: 10
# 2. Spider (Rastreo) Autenticado
- type: spider
  parameters:
    context: auth-context
    user: testuser
    maxDuration: 2
    maxDepth: 5
    url: ${APP_URL}
# 3. Esperar Passive Scan
- type: passiveScan-wait
  parameters:
    maxDuration: 2
# 4. Active Scan (Ataque) Autenticado
- type: activeScan
  parameters:
    context: auth-context
    user: testuser
    maxDuration: 5
    scanPolicy: Default Policy
# 5. Resumen de Salida
- type: outputSummary
  parameters:
    format: json
    summaryFile: /zap/wrk/zap_summary.json
# 6. Generación de Reportes HTML y JSON
- type: report
  parameters:
    reportDir: /zap/wrk/
    reportFile: zap_report.html
    reportTitle: ZAP Authenticated Active Scan Report
    template: traditional-html
- type: report
  parameters:
    reportDir: /zap/wrk/
    reportFile: zap_report.json
    reportTitle: ZAP Authenticated Active Scan Report
    template: traditional-json
"""
                
                // SEGUNDO PASO: Ejecutar la lógica de shell
                sh """
                    # 0. Definir variables y path del intérprete
                    PYTHON_EXE="./venv/bin/python3"
                    APP_URL="${APP_URL}"
                    
                    echo "2. Creando y poblando la base de datos (database.db)..."
                    
                    # Usa un script Python incrustado para crear la DB (similar a create_db.py)
                    \${PYTHON_EXE} - <<'EOF_PYTHON_SCRIPT'
import sqlite3
import hashlib
import time
import os

# ATENCIÓN: El código Flask usa 'database.db' en la raíz.
DB_PATH = 'database.db' 
USER_NAME = 'testuser_zap'
USER_PASS_PLAN = 'TestPassword123' 
DEFAULT_PASS_PLAN = 'password'

def hash_password(password):
    # Simulación de hash de contraseña
    return hashlib.sha256(password.encode()).hexdigest()

USER_PASS_HASH = hash_password(USER_PASS_PLAN)
DEFAULT_PASS_HASH = hash_password(DEFAULT_PASS_PLAN)

conn = None
try:
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    # Crear la tabla de usuarios
    c.execute(\"\"\"
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            username TEXT UNIQUE NOT NULL,
            password TEXT NOT NULL,
            role TEXT NOT NULL DEFAULT 'user'
        );
    \"\"\")
    
    # Crear la tabla de tareas (asumiendo que es una aplicación web típica)
    c.execute(\"\"\"
        CREATE TABLE IF NOT EXISTS tasks (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER NOT NULL,
            task TEXT NOT NULL,
            FOREIGN KEY(user_id) REFERENCES users(id)
        );
    \"\"\")
    
    # Insertar usuario para ZAP (Test user)
    c.execute("INSERT OR IGNORE INTO users (username, password, role) VALUES (?, ?, ?)",
              (USER_NAME, USER_PASS_HASH, 'user'))
              
    # Insertar usuarios por defecto
    c.execute("INSERT OR IGNORE INTO users (username, password, role) VALUES (?, ?, ?)",
              ('admin', DEFAULT_PASS_HASH, 'admin'))
              
    c.execute("INSERT OR IGNORE INTO users (username, password, role) VALUES (?, ?, ?)",
              ('user', DEFAULT_PASS_HASH, 'user'))
              
    conn.commit()
    print(f"Base de datos y usuarios poblados en {DB_PATH}.")
except sqlite3.OperationalError as e:
    print(f"Error al acceder a la base de datos: {e}. ¿La ruta de DB es correcta?")
finally:
    if conn:
        conn.close()
EOF_PYTHON_SCRIPT

                    echo "3. Iniciando aplicación Flask temporal..."
                    # **IMPORTANTE:** Usa 'vulnerable_app.py' como se infirió de tu Dockerfile
                    nohup \${PYTHON_EXE} vulnerable_app.py > flask.log 2>&1 &
                    echo \$! > flask.pid
                    
                    # AÑADIR UN PEQUEÑO RETRASO FIJO antes del bucle de curl
                    echo "Dando 5 segundos a Flask para iniciar..."
                    sleep 5
                    
                    echo "4. Esperando que Flask inicie (Máx 40s)..."
                    READY=0
                    TIMEOUT=20 # 20 intentos * 2 segundos = 40 segundos max
                    COUNT=0
                    
                    # BUCLE WHILE ROBUSTO PARA VERIFICAR LA DISPONIBILIDAD
                    while [ \$COUNT -lt \$TIMEOUT ]; do
                        # Usa >/dev/null para suprimir la salida HTML de curl
                        if curl -s \${APP_URL} >/dev/null; then
                            echo "Flask está corriendo!"
                            READY=1
                            break
                        fi
                        
                        COUNT=\$((COUNT + 1))
                        echo "Esperando... (\$COUNT/\$TIMEOUT)"
                        sleep 2
                    done
                    # FIN DEL BUCLE WHILE

                    if [ "\${READY}" -eq 1 ]; then
                        
                        echo "5. Ejecutando ZAP con Automation Framework..."
                        # Ejecuta ZAP, que ahora puede leer zap.yaml correctamente
                        docker run --rm --network=host \
                            -v "\$(pwd)":/zap/wrk/:rw \
                            ghcr.io/zaproxy/zaproxy:stable \
                            zap.sh -cmd -autorun /zap/wrk/zap.yaml || true
                    else
                        echo "========================================="
                        echo "DIAGNÓSTICO: El servidor Flask no respondió. Revisando flask.log..."
                        if [ -f flask.log ]; then
                            cat flask.log
                        else
                            echo "ERROR: flask.log no encontrado."
                        fi
                        echo "========================================="
                        echo "ADVERTENCIA: Flask no respondió. Saltando ZAP."
                    fi
                """
            }
            post {
                always {
                    sh """
                        # Limpieza
                        if [ -f flask.pid ]; then
                            PID=\$(cat flask.pid)
                            echo "Deteniendo proceso Flask con PID: \$PID"
                            kill "\$PID" || true
                            rm -f flask.pid
                        fi
                        # Limpiar database.db y zap.yaml
                        rm -f database.db || true
                        rm -f zap.yaml || true
                    """
                    archiveArtifacts artifacts: 'zap_report.*, zap_summary.json, flask.log', fingerprint: true
                }
            }
        }

        /* ==========================
         * PUSH DOCKER
         * ========================== */
        stage('Push Docker Image') {
            steps {
                // Asume que la credencial se llama 'dockerhub'
                withCredentials([usernamePassword(
                    credentialsId: 'dockerhub',
                    usernameVariable: 'DOCKER_USER',
                    passwordVariable: 'DOCKER_PASS'
                )]) {
                    sh """
                        # La imagen ya fue construida en la etapa de Snyk Container Scan
                        echo \$DOCKER_PASS | docker login -u \$DOCKER_USER --password-stdin
                        docker push ${DOCKER_IMAGE}
                    """
                }
            }
        }

        /* ==========================
         * DEPLOY EN EC2 (Blue/Green simple)
         * ========================== */
        stage('Deploy to EC2') {
            steps {
                // Asegura permisos para la clave SSH
                sh "chmod 400 ${EC2_KEY}" 
                
                // Ejecución remota del despliegue
                sh """
                    ssh -o StrictHostKeyChecking=no -i ${EC2_KEY} ${EC2_USER}@${EC2_IP} '
                        echo "Deteniendo y eliminando contenedor viejo..."
                        docker stop app || true
                        docker rm app || true
                        
                        echo "Descargando nueva imagen ${DOCKER_IMAGE}..."
                        docker pull ${DOCKER_IMAGE}
                        
                        echo "Iniciando nuevo contenedor..."
                        docker run -d --restart always --name app -p 80:5000 ${DOCKER_IMAGE}
                        
                        echo "Despliegue completado."
                    '
                """
            }
        }
    }

    post {
        always {
            echo "Pipeline completado. Todos los reportes fueron archivados."
        }
    }
}